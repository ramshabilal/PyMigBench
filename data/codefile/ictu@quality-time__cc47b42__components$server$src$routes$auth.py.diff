diff --git a/components/server/src/routes/auth.py b/components/server/src/routes/auth.py
        index 23a4525b4f703b39a097fc8f4e3a7846aa7e1e72..cc47b42cf70b6968b22a3819bf0b9714135271c1 100644
        --- a/components/server/src/routes/auth.py
        +++ b/components/server/src/routes/auth.py
@@ -6,14 +6,16 @@ import os
 import re
 from typing import cast, Dict, Tuple
 import urllib.parse
+import hashlib
+import base64
 
 from pymongo.database import Database
-import ldap
-import bottle
+from ldap3 import Server, Connection, ALL
+from ldap3.core import exceptions
 
+import bottle
 from database import sessions
 from utilities.functions import uuid
-from utilities.ldap import LDAPObject
 from utilities.type import SessionId
 
 
@@ -31,12 +33,27 @@ def set_session_cookie(session_id: str, expires_datetime: datetime) -> None:
         options["domain"] = domain
     bottle.response.set_cookie("session_id", session_id, **options)
 
+def check_password(ssha_ldap_salted_password, password):
+    """Checks the OpenLDAP tagged digest against the given password"""
+
+    if ssha_ldap_salted_password[:6] != b'{SSHA}':
+        logging.warning("Only SSHA LDAP password digest supported!")
+        raise exceptions.LDAPInvalidAttributeSyntaxResult
+
+    digest_salt_b64 = ssha_ldap_salted_password[6:]  # strip {SSHA}
+
+    digest_salt = base64.b64decode(digest_salt_b64)
+    digest = digest_salt[:20]
+    salt = digest_salt[20:]
+
+    sha = hashlib.sha1(bytes(password, 'utf-8'))  #nosec
+    sha.update(salt)  #nosec
+
+    return digest == sha.digest()
 
 @bottle.post("/login")
 def login(database: Database) -> Dict[str, bool]:
     """Log the user in."""
-    # Pylint can't find the ldap.* constants for some reason, turn off the error message:
-    # pylint: disable=no-member
     credentials = dict(bottle.request.json)
     unsafe_characters = re.compile(r"[^\w ]+", re.UNICODE)
     username = re.sub(unsafe_characters, "", credentials.get("username", "no username given"))
@@ -44,23 +61,25 @@ def login(database: Database) -> Dict[str, bool]:
     ldap_url = os.environ.get("LDAP_URL", "ldap://localhost:389")
     ldap_lookup_user = os.environ.get("LDAP_LOOKUP_USER", "admin")
     ldap_lookup_user_password = os.environ.get("LDAP_LOOKUP_USER_PASSWORD", "admin")
-    ldap_server = ldap.initialize(ldap_url)
+
     try:
-        ldap_server.simple_bind_s(f"cn={ldap_lookup_user},{ldap_root_dn}", ldap_lookup_user_password)
-        result = ldap_server.search_s(
-            ldap_root_dn, ldap.SCOPE_SUBTREE, f"(|(uid={username})(cn={username}))", ['dn', 'uid', 'cn'])
-        if result:
-            logging.info("LDAP search result: %s", result)
-            username = LDAPObject(result[0][1]).cn
-        else:
-            raise ldap.INVALID_CREDENTIALS
-        ldap_server.simple_bind_s(f"cn={username},{ldap_root_dn}", credentials.get("password"))
-    except (ldap.INVALID_CREDENTIALS, ldap.UNWILLING_TO_PERFORM, ldap.INVALID_DN_SYNTAX,
-            ldap.SERVER_DOWN) as reason:
-        logging.warning("Couldn't bind cn=%s,%s: %s", username, ldap_root_dn, reason)
+        ldap_server = Server(ldap_url, get_info=ALL)
+        with Connection(ldap_server,
+                        user=f"cn={ldap_lookup_user},{ldap_root_dn}", password=ldap_lookup_user_password) as conn:
+            if not conn.bind():
+                username = ldap_lookup_user
+                raise exceptions.LDAPBindError
+
+            conn.search(ldap_root_dn, f"(|(uid={username})(cn={username}))", attributes=['userPassword'])
+            result = conn.entries[0]
+            password = credentials.get("password", "no password given")
+            if not check_password(result.userPassword.value, password):
+                return dict(ok=False)
+
+    except Exception as reason:  # pylint: disable=broad-except
+        logging.warning("LDAP error for cn=%s,%s: %s", username, ldap_root_dn, reason)
         return dict(ok=False)
-    finally:
-        ldap_server.unbind_s()
+
     session_id, session_expiration_datetime = generate_session()
     sessions.upsert(database, username, session_id, session_expiration_datetime)
     set_session_cookie(session_id, session_expiration_datetime)
