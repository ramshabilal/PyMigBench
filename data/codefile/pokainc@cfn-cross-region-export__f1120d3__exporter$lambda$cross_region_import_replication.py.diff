diff --git a/exporter/lambda/cross_region_import_replication.py b/exporter/lambda/cross_region_import_replication.py
        index 59f1fecb2a7fba013a636a775c51471d2afd793b..f1120d34c2a71686e769995300ac7cf09f858e34 100644
        --- a/exporter/lambda/cross_region_import_replication.py
        +++ b/exporter/lambda/cross_region_import_replication.py
@@ -5,92 +5,73 @@ from uuid import uuid4
 
 import boto3
 import botocore
-from raven import Client
-from raven.transport import HTTPTransport
+import sentry_sdk
+from sentry_sdk.integrations.aws_lambda import AwsLambdaIntegration
 
-MAX_RESOURCES_PER_TEMPLATE = 200
-RESSOURCE_BY_GROUP = 5
+sentry_sdk.init(integrations=[AwsLambdaIntegration(timeout_warning=True)])
+
+MAX_OUTPUTS_PER_TEMPLATE = 200
 
 
 def lambda_handler(*_):
     try:
         _lambda_handler()
     except:
-        # Using a the default transport does not work in a Lambda function.
-        # Must use the HTTPTransport.
-        Client(
-            dsn=os.environ['SENTRY_DSN'],
-            environment=os.environ['SENTRY_ENVIRONMENT'],
-            transport=HTTPTransport
-        ).captureException()
-        # Must raise, otherwise the Lambda will be marked as successful, and the exception
-        # will not be logged to CloudWatch logs.
         raise
 
 
 def _lambda_handler():
-    dynamodb_resource = boto3.resource('dynamodb')
-    cross_stack_ref_table = dynamodb_resource.Table(os.environ['CROSS_STACK_REF_TABLE_NAME'])
+    dynamodb_resource = boto3.resource("dynamodb")
+    cross_stack_ref_table = dynamodb_resource.Table(os.environ["CROSS_STACK_REF_TABLE_NAME"])
 
     scan_response = cross_stack_ref_table.scan()
-    cross_stack_references = scan_response['Items']
+    cross_stack_references = scan_response["Items"]
 
-    while scan_response.get('LastEvaluatedKey'):
-        scan_response = cross_stack_ref_table.scan(ExclusiveStartKey=scan_response['LastEvaluatedKey'])
-        cross_stack_references.extend(scan_response['Items'])
+    while scan_response.get("LastEvaluatedKey"):
+        scan_response = cross_stack_ref_table.scan(ExclusiveStartKey=scan_response["LastEvaluatedKey"])
+        cross_stack_references.extend(scan_response["Items"])
 
     if cross_stack_references:
-        number_of_chunk = len(cross_stack_references) / MAX_RESOURCES_PER_TEMPLATE
-        max_group_size = int(max(min(RESSOURCE_BY_GROUP/number_of_chunk, RESSOURCE_BY_GROUP), 1))
-
         nested_template_urls = []
-        for items in _chunks(cross_stack_references, MAX_RESOURCES_PER_TEMPLATE):
-            nested_template_urls.append(_generate_nested_template(items, max_group_size))
+        for items in _chunks(cross_stack_references, MAX_OUTPUTS_PER_TEMPLATE):
+            nested_template_urls.append(_generate_nested_template(items))
 
         master_template_resources = {}
         for i, url in enumerate(nested_template_urls):
-            master_template_resources[f"ParameterChunk{i}"] = {
-                "Type": "AWS::CloudFormation::Stack",
-                "Properties": {
-                    "TemplateURL": url
-                }
-            }
+            master_template_resources[f"Chunk{i}"] = {"Type": "AWS::CloudFormation::Stack", "Properties": {"TemplateURL": url}}
     else:
         master_template_resources = {
-            'PlaceHolderParameter': {
-                'Type': 'AWS::SSM::Parameter',
-                'Properties': {
-                    'Value': {'Ref': "AWS::StackName"},
-                    'Type': 'String'
-                },
+            "PlaceHolderResource": {
+                "Type": "AWS::CloudFormation::WaitConditionHandle",
+                "Properties": {},
             }
         }
 
     master_template = {
-        'AWSTemplateFormatVersion': '2010-09-09',
-        'Description': 'Auto-generated templates to simulate the standard importation behaviour on other regions',
-        'Resources': master_template_resources
+        "AWSTemplateFormatVersion": "2010-09-09",
+        "Description": "Auto-generated templates to simulate the standard importation behaviour on other regions",
+        "Resources": master_template_resources,
     }
 
-    cloudformation_client = boto3.client('cloudformation')
+    cloudformation_client = boto3.client("cloudformation")
 
-    _upload_template(os.environ['GENERATED_STACK_NAME'], json.dumps(master_template))
-    template_url = _build_unsigned_url(os.environ['GENERATED_STACK_NAME'])
+    _upload_template(os.environ["GENERATED_STACK_NAME"], json.dumps(master_template))
+    template_url = _build_unsigned_url(os.environ["GENERATED_STACK_NAME"])
 
     try:
         cloudformation_client.update_stack(
-            StackName=os.environ['GENERATED_STACK_NAME'],
+            StackName=os.environ["GENERATED_STACK_NAME"],
             TemplateURL=template_url,
         )
     except botocore.exceptions.ClientError as e:
-        message = e.response['Error']['Message']
-        if 'does not exist' in message:
+        message = e.response["Error"]["Message"]
+        if "does not exist" in message:
             cloudformation_client.create_stack(
-                StackName=os.environ['GENERATED_STACK_NAME'],
+                StackName=os.environ["GENERATED_STACK_NAME"],
                 TemplateURL=template_url,
             )
-        elif 'No updates are to be performed.' in message:
-            print('No updates are to be performed.')
+        elif "No updates are to be performed." in message:
+            print("No updates are to be performed.")
         else:
             raise
 
@@ -100,63 +81,46 @@ def _generate_hash(string_to_hash):
 
 
 def _upload_template(template_name, template_content):
-    s3_resource = boto3.resource('s3')
-    template_object = s3_resource.Object(os.environ['TEMPLATE_BUCKET'], template_name)
+    s3_resource = boto3.resource("s3")
+    template_object = s3_resource.Object(os.environ["TEMPLATE_BUCKET"], template_name)
     template_object.put(Body=template_content.encode())
 
 
 def _build_unsigned_url(template_name):
-    s3_resource = boto3.resource('s3')
-    template_object = s3_resource.Object(
-        os.environ['TEMPLATE_BUCKET'],
-        template_name
-    )
+    s3_resource = boto3.resource("s3")
+    template_object = s3_resource.Object(os.environ["TEMPLATE_BUCKET"], template_name)
 
-    return '{host}/{bucket}/{key}'.format(
+    return "{host}/{bucket}/{key}".format(
         host=template_object.meta.client.meta.endpoint_url,
         bucket=template_object.bucket_name,
         key=template_object.key,
     )
 
 
-def _generate_nested_template(cross_stack_references, max_group_size):
-    last_ref_id = None
-    ssm_resources = {}
-    resource_count = 0
+def _generate_nested_template(cross_stack_references):
+    template = {
+        "AWSTemplateFormatVersion": "2010-09-09",
+        "Resources": {
+            "PlaceHolderResource": {"Type": "AWS::CloudFormation::WaitConditionHandle", "Properties": {}},
+        },
+        "Outputs": {},
+    }
 
     for ref in cross_stack_references:
-        ref_id = _generate_hash(ref['CrossStackRefId'])
-        ssm_resource = {
-            'Type': 'AWS::SSM::Parameter',
-            'Properties': {
-                'Name': {'Fn::Sub': "${AWS::StackName}." + ref_id},
-                'Description': f'Imported by {ref["ImporterStackId"]}.{ref["ImporterLogicalResourceId"]}.{ref["ImporterLabel"]}',
-                'Value': {'Fn::ImportValue': ref['ExportName']},
-                'Type': 'String'
-            },
+        ref_id = _generate_hash(ref["CrossStackRefId"])
+        output = {
+            "Value": {"Fn::ImportValue": ref["ExportName"]},
+            "Description": f'Imported by {ref["ImporterStackId"]}.{ref["ImporterLogicalResourceId"]}.{ref["ImporterLabel"]}',
         }
 
-        if last_ref_id:
-            ssm_resource['DependsOn'] = last_ref_id  # Required to prevent SSM throttling exceptions
-
-        ssm_resources[ref_id] = ssm_resource
-
-        if resource_count % max_group_size == 0:
-            last_ref_id = ref_id
-
-        resource_count += 1
-
-    imports_replication_template = {
-        'AWSTemplateFormatVersion': '2010-09-09',
-        'Resources': ssm_resources
-    }
+        template["Outputs"][ref_id] = output
 
     template_name = f'{os.environ["GENERATED_STACK_NAME"]}.{uuid4()}'
 
-    _upload_template(template_name, json.dumps(imports_replication_template))
+    _upload_template(template_name, json.dumps(template))
     return _build_unsigned_url(template_name)
 
 
 def _chunks(l, n):
     for i in range(0, len(l), n):
-        yield l[i:i + n]
+        yield l[i : i + n]
